{"version":3,"sources":["../../../../../../node_modules/babel-traverse/lib/path/inference/inferer-reference.js"],"names":["exports","__esModule","_getIterator2","require","_getIterator3","_interopRequireDefault","default","node","isReferenced","binding","scope","getBinding","name","identifier","typeAnnotation","getTypeAnnotationBindingConstantViolations","t","voidTypeAnnotation","numberTypeAnnotation","_babelTypes","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","path","types","unionTypeAnnotation","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","filter","indexOf","push","length","concat","_iterator","_isArray","Array","isArray","_i","_ref","next","done","value","violation","getTypeAnnotation","createUnionTypeAnnotation","functions","violations","slice","unshift","resolve","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","operator","right","get","left","target","isIdentifier","BOOLEAN_NUMBER_BINARY_OPERATORS","typeofPath","typePath","isUnaryExpression","isLiteral","typeValue","createTypeAnnotationBasedOnTypeof","getParentConditionalPath","parentPath","isIfStatement","isConditionalExpression","test","paths","_path","shift","isLogicalExpression","isBinaryExpression","type","module"],"mappings":"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","file":"inferer-reference.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.default = function (node) {\n  if (!this.isReferenced()) return;\n\n  var binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n};\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n\n  var testType = getConditionalAnnotation(path, name);\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var violation = _ref;\n\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n    var status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n\n  var target = void 0;\n  if (left.isIdentifier({ name: name })) {\n    target = right;\n  } else if (right.isIdentifier({ name: name })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  var typeofPath = void 0;\n  var typePath = void 0;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typePath && !typeofPath) return;\n\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  if (!typeofPath.get(\"argument\").isIdentifier({ name: name })) return;\n\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\nfunction getParentConditionalPath(path) {\n  var parentPath = void 0;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\nmodule.exports = exports[\"default\"];"]}